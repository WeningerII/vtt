generator client {
  provider = "prisma-client-js"
  output   = "../../../node_modules/.prisma/client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum AssetKind {
  ORIGINAL
  DEPTH
  MASK
  TILE
  THUMBNAIL
  METADATA
}

enum JobType {
  TEXT_TO_IMAGE
  DEPTH
  SEGMENTATION
}

enum JobStatus {
  QUEUED
  RUNNING
  SUCCEEDED
  FAILED
  CANCELED
}

enum TokenType {
  PC
  NPC
  MONSTER
  OBJECT
  EFFECT
}

enum TokenVisibility {
  VISIBLE
  HIDDEN
  PARTIAL
  REVEALED
}

enum GameSessionStatus {
  WAITING
  ACTIVE
  PAUSED
  COMPLETED
  ABANDONED
}

enum EncounterStatus {
  PLANNED
  ACTIVE
  PAUSED
  COMPLETED
}

model Map {
  id         String   @id @default(uuid())
  name       String
  widthPx    Int
  heightPx   Int
  gridSizePx Int      @default(70)
  createdAt  DateTime @default(now())

  scenes     Scene[]
  assets     Asset[]
  jobs       GenerationJob[]

  @@index([name]) // For map search
  @@index([createdAt]) // For pagination and sorting
  @@index([widthPx, heightPx]) // For size-based queries
}

model User {
  id              String   @id @default(uuid())
  email           String   @unique
  username        String   @unique
  displayName     String
  passwordHash    String
  avatar          String?
  role            String   @default("player") // admin, moderator, gamemaster, player, guest
  permissions     Json     @default("[]") // Array of permission strings
  subscription    String   @default("free") // free, basic, premium, enterprise
  isEmailVerified Boolean  @default(false)
  lastLogin       DateTime?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  memberships     CampaignMember[]
  messages        ChatMessage[]
  refreshTokens   RefreshToken[]

  @@index([email]) // For login
  @@index([username]) // For username lookup
  @@index([displayName]) // For user search
  @@index([createdAt]) // For pagination and sorting
}

model RefreshToken {
  id        String   @id @default(uuid())
  token     String   @unique
  userId    String
  expiresAt DateTime
  createdAt DateTime @default(now())
  
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId])
  @@index([token])
  @@index([expiresAt])
}

model Campaign {
  id            String   @id @default(uuid())
  name          String
  activeSceneId String?
  createdAt     DateTime @default(now())
  members       CampaignMember[]
  scenes        Scene[]
  settings      CampaignSettings?
  characters    CampaignCharacter[]

  @@index([name]) // For campaign search
  @@index([createdAt]) // For pagination and sorting
  @@index([activeSceneId]) // For active scene queries
}

model CampaignMember {
  id         String   @id @default(uuid())
  role       String
  status     String   @default("active") // active, invited, kicked, banned
  userId     String
  campaignId String
  joinedAt   DateTime @default(now())
  invitedAt  DateTime?
  invitedBy  String?
  user       User     @relation(fields: [userId], references: [id])
  campaign   Campaign @relation(fields: [campaignId], references: [id])

  @@unique([userId, campaignId])
  @@index([userId]) // Foreign key index
  @@index([campaignId]) // Foreign key index
  @@index([role, campaignId]) // For role-based queries
  @@index([status, campaignId]) // For status-based queries
}

model Scene {
  id         String   @id @default(uuid())
  name       String
  campaignId String
  mapId      String?
  createdAt  DateTime @default(now())
  campaign   Campaign @relation(fields: [campaignId], references: [id])
  map        Map?     @relation(fields: [mapId], references: [id])

  @@index([campaignId]) // Foreign key index
  @@index([mapId]) // Foreign key index
  @@index([campaignId, createdAt]) // For campaign scene listing with sort
}

model ChatMessage {
  id         String   @id @default(uuid())
  campaignId String
  authorId   String
  channel    String
  text       String
  timestamp  DateTime @default(now())
  author     User     @relation(fields: [authorId], references: [id])

  @@index([campaignId, timestamp]) // For chat history queries
  @@index([authorId]) // Foreign key index
  @@index([channel, campaignId]) // For channel-specific messages
  @@index([timestamp]) // For global message timeline
}

/// Generated character sheets from Genisis
model Character {
  id         String   @id @default(uuid())
  name       String
  sheet      Json
  prompt     String
  provider   String
  model      String
  cost       Float    @default(0)
  latencyMs  Int
  createdAt  DateTime @default(now())
  
  campaigns  CampaignCharacter[]

  @@index([name]) // For character search
  @@index([provider, model]) // For provider analytics
  @@index([createdAt]) // For pagination and sorting
  @@index([cost]) // For cost analytics
}

model CampaignCharacter {
  id          String   @id @default(uuid())
  campaignId  String
  characterId String
  addedBy     String   // User ID who added the character
  role        String   @default("player") // "player", "npc", "enemy"
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  
  campaign    Campaign @relation(fields: [campaignId], references: [id], onDelete: Cascade)
  character   Character @relation(fields: [characterId], references: [id], onDelete: Cascade)
  
  @@unique([campaignId, characterId]) // Prevent duplicate character assignments
  @@index([campaignId]) // For campaign character queries
  @@index([characterId]) // For character campaign queries
  @@index([addedBy]) // For user character queries
}

/// Monster statblocks and data for encounters
model Monster {
  id         String   @id @default(uuid())
  stableId   String   @unique // Stable identifier for SRD monsters
  name       String
  statblock  Json     // Full monster statblock data
  tags       Json     @default("[]") // Tags for categorization and search (JSON array)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([name]) // For monster search
  @@index([stableId]) // For SRD monster lookup
  @@index([createdAt]) // For pagination and sorting
}

model Asset {
  id        String   @id @default(uuid())
  mapId     String?
  map       Map?     @relation(fields: [mapId], references: [id])
  kind      AssetKind
  uri       String
  mimeType  String?
  width     Int?
  height    Int?
  sizeBytes Int?
  checksum  String?
  createdAt DateTime @default(now())

  @@index([mapId])
}

model GenerationJob {
  id        String    @id @default(uuid())
  type      JobType
  status    JobStatus
  input     Json
  output    Json?
  error     String?
  mapId     String?
  map       Map?      @relation(fields: [mapId], references: [id])
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  calls     ProviderCall[]

  @@index([mapId])
  @@index([status, type]) // For job queue queries
  @@index([createdAt]) // For job history
  @@index([updatedAt]) // For recent updates
  @@index([status, updatedAt]) // For monitoring failed/stuck jobs
}

model ProviderCall {
  id        String        @id @default(uuid())
  jobId     String
  job       GenerationJob @relation(fields: [jobId], references: [id])
  provider  String
  model     String?
  costUSD   Float         @default(0)
  latencyMs Int?
  success   Boolean       @default(true)
  error     String?
  createdAt DateTime      @default(now())

  @@index([jobId])
  @@index([provider, model]) // For provider analytics
  @@index([success, provider]) // For error rate monitoring
  @@index([createdAt]) // For time-series analytics
  @@index([costUSD]) // For cost analytics
}

model Token {
  id              String          @id @default(uuid())
  name            String
  type            TokenType
  visibility      TokenVisibility @default(VISIBLE)
  gameSessionId   String
  sceneId         String?
  characterId     String?
  x               Float           @default(0)
  y               Float           @default(0)
  z               Float           @default(0)
  rotation        Float           @default(0)
  scale           Float           @default(1)
  health          Int?
  maxHealth       Int?
  initiative      Int?
  speed           Int             @default(30)
  imageUrl        String?
  metadata        Json?
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  
  gameSession     GameSession     @relation(fields: [gameSessionId], references: [id], onDelete: Cascade)
  encounterTokens EncounterToken[]

  @@index([gameSessionId]) // For session-based queries
  @@index([sceneId]) // For scene-based queries
  @@index([type]) // For filtering by token type
  @@index([visibility]) // For visibility filtering
  @@index([gameSessionId, sceneId]) // For session+scene queries
  @@index([x, y]) // For spatial queries
}

model GameSession {
  id              String            @id @default(uuid())
  name            String
  campaignId      String
  status          GameSessionStatus @default(WAITING)
  currentSceneId  String?
  currentTurn     Int               @default(0)
  roundNumber     Int               @default(1)
  startedAt       DateTime?
  endedAt         DateTime?
  metadata        Json?
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  
  tokens          Token[]
  encounters      Encounter[]
  
  @@index([campaignId]) // For campaign-based queries
  @@index([status]) // For status filtering
  @@index([createdAt]) // For pagination and sorting
  @@index([startedAt]) // For active session queries
  @@index([campaignId, status]) // For campaign active sessions
}

model Encounter {
  id              String            @id @default(uuid())
  name            String
  gameSessionId   String
  sceneId         String?
  status          EncounterStatus   @default(PLANNED)
  initiativeOrder Json?             // Array of token IDs in initiative order
  currentTurn     Int               @default(0)
  roundNumber     Int               @default(1)
  startedAt       DateTime?
  endedAt         DateTime?
  metadata        Json?
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  
  gameSession     GameSession       @relation(fields: [gameSessionId], references: [id], onDelete: Cascade)
  encounterTokens EncounterToken[]
  
  @@index([gameSessionId]) // For session-based queries
  @@index([status]) // For status filtering
  @@index([sceneId]) // For scene-based queries
  @@index([gameSessionId, status]) // For session active encounters
  @@index([startedAt]) // For active encounter queries
}

model EncounterToken {
  id          String    @id @default(uuid())
  encounterId String
  tokenId     String
  initiative  Int?
  turnOrder   Int?
  isActive    Boolean   @default(true)
  joinedAt    DateTime  @default(now())
  leftAt      DateTime?
  
  encounter   Encounter @relation(fields: [encounterId], references: [id], onDelete: Cascade)
  token       Token     @relation(fields: [tokenId], references: [id], onDelete: Cascade)
  
  @@unique([encounterId, tokenId])
  @@index([encounterId]) // For encounter queries
  @@index([tokenId]) // For token queries
  @@index([initiative]) // For initiative sorting
  @@index([isActive]) // For active token filtering
}

model CampaignSettings {
  id                String   @id @default(uuid())
  campaignId        String   @unique
  description       String   @default("")
  gameSystem        String   @default("dnd5e")
  isActive          Boolean  @default(true)
  isPublic          Boolean  @default(false)
  allowSpectators   Boolean  @default(true)
  maxPlayers        Int      @default(6)
  autoAcceptInvites Boolean  @default(false)
  requireApproval   Boolean  @default(true)
  sessionTimeout    Int      @default(240) // minutes
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  
  campaign          Campaign @relation(fields: [campaignId], references: [id], onDelete: Cascade)
  
  @@index([campaignId]) // For campaign settings lookup
  @@index([isActive]) // For active campaign filtering
}

enum ConditionType {
  BUFF
  DEBUFF
  NEUTRAL
}

model Condition {
  id              String        @id @default(uuid())
  name            String
  type            ConditionType
  description     String        @default("")
  duration        Int?          // Duration in rounds, null for permanent
  metadata        Json?         // Additional condition data (damage per turn, stat modifiers, etc.)
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  
  appliedConditions AppliedCondition[]
  
  @@index([name]) // For condition search
  @@index([type]) // For filtering by condition type
  @@index([createdAt]) // For pagination and sorting
}

model AppliedCondition {
  id            String    @id @default(uuid())
  conditionId   String
  targetId      String    // Can reference Token, Character, or other entities
  targetType    String    // "token", "character", "encounterParticipant", etc.
  duration      Int?      // Remaining duration in rounds, null for permanent
  metadata      Json?     // Instance-specific data (current damage taken, etc.)
  appliedBy     String?   // ID of who/what applied this condition
  appliedAt     DateTime  @default(now())
  expiresAt     DateTime? // Calculated expiration time
  isActive      Boolean   @default(true)
  
  condition     Condition @relation(fields: [conditionId], references: [id], onDelete: Cascade)
  
  @@index([targetId, targetType]) // For finding conditions on a target
  @@index([conditionId]) // Foreign key index
  @@index([isActive]) // For active condition filtering
  @@index([expiresAt]) // For expiration cleanup
  @@index([appliedAt]) // For condition history
}

generator client {
  provider = "prisma-client-js"
  output   = "../../../node_modules/.prisma/client"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

enum AssetKind {
  ORIGINAL
  DEPTH
  MASK
  TILE
  THUMBNAIL
  METADATA
}

enum JobType {
  TEXT_TO_IMAGE
  DEPTH
  SEGMENTATION
}

enum JobStatus {
  QUEUED
  RUNNING
  SUCCEEDED
  FAILED
  CANCELED
}

enum TokenType {
  PC
  NPC
  MONSTER
  OBJECT
  EFFECT
}

enum TokenVisibility {
  VISIBLE
  HIDDEN
  PARTIAL
  REVEALED
}

enum GameSessionStatus {
  WAITING
  ACTIVE
  PAUSED
  COMPLETED
  ABANDONED
}

enum EncounterStatus {
  PLANNED
  ACTIVE
  PAUSED
  COMPLETED
}

model Map {
  id         String   @id @default(uuid())
  name       String
  widthPx    Int
  heightPx   Int
  gridSizePx Int      @default(70)
  createdAt  DateTime @default(now())

  scenes     Scene[]
  assets     Asset[]
  jobs       GenerationJob[]

  @@index([name]) // For map search
  @@index([createdAt]) // For pagination and sorting
  @@index([widthPx, heightPx]) // For size-based queries
}

model User {
  id          String   @id @default(uuid())
  displayName String
  createdAt   DateTime @default(now())
  memberships CampaignMember[]
  messages    ChatMessage[]

  @@index([displayName]) // For user search
  @@index([createdAt]) // For pagination and sorting
}

model Campaign {
  id        String   @id @default(uuid())
  name      String
  createdAt DateTime @default(now())
  members   CampaignMember[]
  scenes    Scene[]

  @@index([name]) // For campaign search
  @@index([createdAt]) // For pagination and sorting
}

model CampaignMember {
  id         String   @id @default(uuid())
  role       String
  userId     String
  campaignId String
  user       User     @relation(fields: [userId], references: [id])
  campaign   Campaign @relation(fields: [campaignId], references: [id])

  @@unique([userId, campaignId])
  @@index([userId]) // Foreign key index
  @@index([campaignId]) // Foreign key index
  @@index([role, campaignId]) // For role-based queries
}

model Scene {
  id         String   @id @default(uuid())
  name       String
  campaignId String
  mapId      String?
  createdAt  DateTime @default(now())
  campaign   Campaign @relation(fields: [campaignId], references: [id])
  map        Map?     @relation(fields: [mapId], references: [id])

  @@index([campaignId]) // Foreign key index
  @@index([mapId]) // Foreign key index
  @@index([campaignId, createdAt]) // For campaign scene listing with sort
}

model ChatMessage {
  id         String   @id @default(uuid())
  campaignId String
  authorId   String
  channel    String
  text       String
  timestamp  DateTime @default(now())
  author     User     @relation(fields: [authorId], references: [id])

  @@index([campaignId, timestamp]) // For chat history queries
  @@index([authorId]) // Foreign key index
  @@index([channel, campaignId]) // For channel-specific messages
  @@index([timestamp]) // For global message timeline
}

/// Generated character sheets from Genisis
model Character {
  id         String   @id @default(uuid())
  name       String
  sheet      Json
  prompt     String
  provider   String
  model      String
  cost       Float    @default(0)
  latencyMs  Int
  createdAt  DateTime @default(now())

  @@index([name]) // For character search
  @@index([provider, model]) // For provider analytics
  @@index([createdAt]) // For pagination and sorting
  @@index([cost]) // For cost analytics
}

model Asset {
  id        String   @id @default(uuid())
  mapId     String?
  map       Map?     @relation(fields: [mapId], references: [id])
  kind      AssetKind
  uri       String
  mimeType  String?
  width     Int?
  height    Int?
  sizeBytes Int?
  checksum  String?
  createdAt DateTime @default(now())

  @@index([mapId])
}

model GenerationJob {
  id        String    @id @default(uuid())
  type      JobType
  status    JobStatus
  input     Json
  output    Json?
  error     String?
  mapId     String?
  map       Map?      @relation(fields: [mapId], references: [id])
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  calls     ProviderCall[]

  @@index([mapId])
  @@index([status, type]) // For job queue queries
  @@index([createdAt]) // For job history
  @@index([updatedAt]) // For recent updates
  @@index([status, updatedAt]) // For monitoring failed/stuck jobs
}

model ProviderCall {
  id        String        @id @default(uuid())
  jobId     String
  job       GenerationJob @relation(fields: [jobId], references: [id])
  provider  String
  model     String?
  costUSD   Float         @default(0)
  latencyMs Int?
  success   Boolean       @default(true)
  error     String?
  createdAt DateTime      @default(now())

  @@index([jobId])
  @@index([provider, model]) // For provider analytics
  @@index([success, provider]) // For error rate monitoring
  @@index([createdAt]) // For time-series analytics
  @@index([costUSD]) // For cost analytics
}

model Token {
  id              String          @id @default(uuid())
  name            String
  type            TokenType
  visibility      TokenVisibility @default(VISIBLE)
  gameSessionId   String
  sceneId         String?
  characterId     String?
  x               Float           @default(0)
  y               Float           @default(0)
  z               Float           @default(0)
  rotation        Float           @default(0)
  scale           Float           @default(1)
  health          Int?
  maxHealth       Int?
  initiative      Int?
  speed           Int             @default(30)
  imageUrl        String?
  metadata        Json?
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  
  gameSession     GameSession     @relation(fields: [gameSessionId], references: [id], onDelete: Cascade)
  encounterTokens EncounterToken[]

  @@index([gameSessionId]) // For session-based queries
  @@index([sceneId]) // For scene-based queries
  @@index([type]) // For filtering by token type
  @@index([visibility]) // For visibility filtering
  @@index([gameSessionId, sceneId]) // For session+scene queries
  @@index([x, y]) // For spatial queries
}

model GameSession {
  id              String            @id @default(uuid())
  name            String
  campaignId      String
  status          GameSessionStatus @default(WAITING)
  currentSceneId  String?
  currentTurn     Int               @default(0)
  roundNumber     Int               @default(1)
  startedAt       DateTime?
  endedAt         DateTime?
  metadata        Json?
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  
  tokens          Token[]
  encounters      Encounter[]
  
  @@index([campaignId]) // For campaign-based queries
  @@index([status]) // For status filtering
  @@index([createdAt]) // For pagination and sorting
  @@index([startedAt]) // For active session queries
  @@index([campaignId, status]) // For campaign active sessions
}

model Encounter {
  id              String            @id @default(uuid())
  name            String
  gameSessionId   String
  sceneId         String?
  status          EncounterStatus   @default(PLANNED)
  initiativeOrder Json?             // Array of token IDs in initiative order
  currentTurn     Int               @default(0)
  roundNumber     Int               @default(1)
  startedAt       DateTime?
  endedAt         DateTime?
  metadata        Json?
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  
  gameSession     GameSession       @relation(fields: [gameSessionId], references: [id], onDelete: Cascade)
  encounterTokens EncounterToken[]
  
  @@index([gameSessionId]) // For session-based queries
  @@index([status]) // For status filtering
  @@index([sceneId]) // For scene-based queries
  @@index([gameSessionId, status]) // For session active encounters
  @@index([startedAt]) // For active encounter queries
}

model EncounterToken {
  id          String    @id @default(uuid())
  encounterId String
  tokenId     String
  initiative  Int?
  turnOrder   Int?
  isActive    Boolean   @default(true)
  joinedAt    DateTime  @default(now())
  leftAt      DateTime?
  
  encounter   Encounter @relation(fields: [encounterId], references: [id], onDelete: Cascade)
  token       Token     @relation(fields: [tokenId], references: [id], onDelete: Cascade)
  
  @@unique([encounterId, tokenId])
  @@index([encounterId]) // For encounter queries
  @@index([tokenId]) // For token queries
  @@index([initiative]) // For initiative sorting
  @@index([isActive]) // For active token filtering
}
